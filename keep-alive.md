持久连接会在不同事务之间保持打开状态，直到客户端或服务器决定将其关闭为止。重用已对目标服务器打开的空闲持久连接，就可以避开缓慢的连接建立过程和慢启动的拥塞适应阶段，以便更快速地进行数据的传输。  

# 持久连接有两种类型
## HTTP/1.0 的 keep-alive 连接
实现 HTTP/1.0 keep-alive 连接的客户端可以通过包含 connection: Keep-Alive 首部请求将一条连接保持在打开状态。如果服务器愿意为下一条请求将连接保持在打开状态，就在响应中包含相同的首部。如果响应中没有 connection: Keep-Alive 首部，客户端就认为服务器不支持 keep-alive，会在发回响应报文之后关闭连接。注意，此版本的 keep-alive 已不再使用了。  

问题：问题出在代理上———尤其是那些不能理解 Connection 首部，而且不知道在沿着转发链路将其发送出去之前，应该将该首部删除的代理。很多老的或简单的代理都是盲中继，它们只是将字节从一个连接发送到另一个连接中去，不对 Connection 首部进行特殊的处理。  
![blind-relay](/images/blind-relay.png)  
1. 由于代理对 keep-alive 一无所知，所以会将收到的所有数据都回送给客户端，然后等待源端服务器关闭连接。但源端服务器会认为代理已经显式地请求它将连接保持在打开状态了，所以不会去关闭连接。这样，代理就会挂在那里等待连接的关闭。  
2. 客户端在步骤d中收到了回送的响应报文时，会立即转向下一条请求，在 keep-alive 连接上向代理发送另一条请求(步骤e)。而代理并不认为同一条连接上会有其他请求到来，请求被忽略，浏览器就在这里转圈，不会有任何进展了。
3. 这种错误的通信方式会使浏览器一直处于挂起状态，直到客户端或服务器将连接超时,并将其关闭为止。  
**因此，现代的代理是绝不能转发与 Connection 有关的首部**
## HTTP/1.1 的 persistent 连接 
HTTP/1.1 逐渐停止了对 keep-alive 连接的支持，用一种名为持久连接的改进型设计取代了它。HTTP/1.1 持久连接在默认情况下是激活的，HTTP/1.1 必须向报文中显式地添加一个 Connection: close 首部，才能在事务处理结束之后将连接关闭。但是，客户端和服务器仍然可以随时关闭空闲的连接。  

持久连接降低了时延和连接建立的开销，将连接保持在已调谐状态，而且减少了打开连接的潜在数量。但是，管理持久连接时要特别小心，不然就会累积出大量的空闲连接，耗费本地以及远程客户端和服务器上的资源。持久连接与并行连接配合使用可能是最高效的方式。现在，很多 Web 应用程序都会打开少量的并行连接，其中的每一个都是持久连接。