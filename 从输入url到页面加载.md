# 发送 url 到页面中，发生了什么?
超长文预警！！！
## 输入url
用户在输入 url 的时候，浏览器会尝试自动扩展 url，扩展方式有以下两种：  
1. 主机名扩展  
浏览器通常会将你输入的主机名扩展成完整的主机名。比如，如果在地址栏中输入 yahoo，浏览器会自动插入www.前缀和.com后缀，构建出完整主机名www.yahoo.com。  
2. 历史扩展  
浏览器将用户以前访问过的 url 历史存储起来，当用户输入 url 时，浏览器将用户输入的 url 与历史记录中的 url 的前缀进行匹配，并提供一些完整的 url 供用户选择。如果你输入了一个以前访问过的一个 url 的开始部分，比如http:\/\/www.joes-，浏览器可能会建议使用http:\/\/www.joes-hardware.com。  
## 解析url
根据是否有代理，浏览器对请求 url 的解析会有所不同。另外，还需要注意的是，客户端会在请求中包含完整的 url，发送给经过显示配置的代理，如果客户端无法确定下一跳是代理还是原始服务器，只会发送部分 url。  
1. 没有代理时 url 的解析  
    ![没有代理](/images/noproxy.png)  
    客户端发送的请求中包含部分 url。  
    - 在第（1）步中，用户向浏览器的 ur l窗口输入 oreilly，浏览器用 oreilly 作为主机名，并假定默认方案为http:\/\/，默认端口为80，默认路径为“/”。  
    - 在第（2a）步中，浏览器会去查找主机 oreilly。查找失败了。  
    - 在第（3a）步中，浏览器对主机名自动扩展，请求 DNS 解析www.oreilly.com。这次成功了。  
    - 然后，浏览器成功连接了www.oreilly.com。  
2. 有显示代理时 url 的解析  
    ![显示代理](/images/xianshiProxy.png)    
    客户端发送的请求中包含完整 url。  
    使用显示代理时，浏览器不会对不完整的主机名进行自动扩展，用户的 url 会被直接发送给代理，当用户在浏览器窗口中输入 oreilly 时，发送给代理的就是http:\/\/oreilly\/。    
    因此，有些代理会尽力尝试着去模仿浏览器的便捷服务，包括www...com自动扩展。  
3. 有拦截代理时 url 的解析  
    ![拦截代理](/images/lanjieProxy.png)  
    使用不可见的拦截代理时，对客户端来说，是没有代理的，浏览器会自动扩展主机名，直到 DNS 成功为止。同样因为客户端以为下一跳是原始服务器，因此发送的请求中只包含部分 url。  
    - 直到（3b）这一步，解析过程都和没有代理时的解析过程相同。  
    - 在第（4a）步中，客户端已经成功解析了主机名，并有了一张 IP 地址列表。有些 IP 地址可能已经停用了，所以，客户端通常会尝试着连接每个 IP 地址，直到成功为止。但对拦截代理来说，第一次连接请求就会被代理服务器拦截成功，不会连接到原始服务器上去。客户端认为它在与Web服务器进行成功的对话，但那个Web服务器可能甚至都不处于活跃状态。  
    - 当代理最终准备与原始服务器进行交互时（5b），代理可能会发现那个 IP 地址实际指向的是一个已停用的服务器。为了提供与浏览器相同级别的容错机制，代理可以通过解析 Host 首部的主机名，也可以通过对 IP 地址的反向 DNS 查找来尝试其他 IP 地址。  
## DNS 解析:将域名解析成 IP 地址  
查看另一篇文章[DNS查询原理](https://github.com/adele-ty/HTTP/blob/main/DNS%E6%9F%A5%E8%AF%A2%E5%8E%9F%E7%90%86.md)
## TCP 连接：TCP 三次握手  
**为了保证服务端能收接受到客户端的信息并能做出正确的应答而进行前两次(第一次和第二次)握手，为了保证客户端能够接收到服务端的信息并能做出正确的应答而进行后两次(第二次和第三次)握手。**  

先了解几个相关信息：  
SYN: 在连接建立时用来同步序号。当SYN=1而ACK=0时，表明这是一个连接请求报文。对方若同意建立连接，则应在响应报文中使SYN=1和ACK=1。因此, SYN置1就表示这是一个连接请求或连接接受报文。  

seq(Sequence Number): 用来标识从TCP发端向TCP收端发送的数据字节流，它表示在这个报文段中的的第一个数据字节在数据流中的序号，主要用来解决网络报乱序的问题。  

ACK(Acknowledgment Number): 32位确认序列号包含发送确认的一端所期望收到的下一个序号，因此，确认序号应当是上次已成功收到数据字节序号加1。不过，只有当标志位中的ACK标志为1时该确认序列号的字段才有效。主要用来解决不丢包的问题。  
![拦截代理](/images/tcp-connection.png)  
以下就是三次握手的过程：  
- 第一次握手：建立连接。客户端发送连接请求报文段，将SYN位置为1，Sequence Number为x；然后，客户端进入SYN_SEND状态，等待服务器的确认；  
- 第二次握手：服务器收到SYN报文段。服务器收到客户端的SYN报文段，需要对这个SYN报文段进行确认，设置Acknowledgment Number为x+1(Sequence Number+1)；同时，自己还要发送SYN请求信息，将SYN位置为1，Sequence Number为y；服务器端将上述所有信息放到一个报文段（即SYN+ACK报文段）中，一并发送给客户端，此时服务器进入SYN_RECV状态；  
- 第三次握手：客户端收到服务器的SYN+ACK报文段。然后将Acknowledgment Number设置为y+1，向服务器发送ACK报文段，这个报文段发送完毕以后，客户端和服务器端都进入ESTABLISHED状态，完成TCP三次握手。  
完成了三次握手，客户端和服务器端就可以开始传送数据。  
查看[三次握手四次挥手](https://github.com/jawil/blog/issues/14)
## 浏览器向服务器发送 HTTP 请求报文  

## 服务器向浏览器回送 HTTP 响应报文  

## 断开连接：TCP 四次挥手  
以下是四次挥手的过程：  
- 第一次分手：主机1（可以使客户端，也可以是服务器端），设置Sequence Number和Acknowledgment Number，向主机2发送一个FIN报文段；此时，主机1进入FIN_WAIT_1状态；这表示主机1没有数据要发送给主机2了；  
- 第二次分手：主机2收到了主机1发送的FIN报文段，向主机1回一个ACK报文段，Acknowledgment Number为Sequence Number加1；主机1进入FIN_WAIT_2状态；主机2告诉主机1，我“同意”你的关闭请求；  
- 第三次分手：主机2向主机1发送FIN报文段，请求关闭连接，同时主机2进入LAST_ACK状态；  
- 第四次分手：主机1收到主机2发送的FIN报文段，向主机2发送ACK报文段，然后主机1进入TIME_WAIT状态；主机2收到主机1的ACK报文段以后，就关闭连接；此时，主机1等待2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，主机1也可以关闭连接了。  
## 浏览器解析渲染页面

参考[发送url到页面中，发生了什么](https://segmentfault.com/a/1190000006879700)  
参考[从输入url到页面加载的过程](https://dailc.github.io/2018/03/12/whenyouenteraurl.html)  
参考[从输入 URL 到页面加载完成](http://fex.baidu.com/blog/2014/05/what-happen/)
